# lost-cities-board-game

Lost cities – Minoan Civilization is a Java-based implementation of the classic two-player strategic board game. This project showcases my exploration of game development, utilizing Java language and the Model-View-Controller (MVC) architectural pattern for the needs of a university project.



## How to run
To run the application you just have to run the jar file 
by double-clicking it or 
by command line using the command: java -jar PhaseA.jar

## Features

- **MVC Architecture:** The game's structure is organized following the MVC model for better code organization and debugging. According to this standard, the development of the graphical interface of the game (View) is separated from the core of the game that contains all the state information (Model) and from the mechanism for managing and updating the actions of the game with its graphic representation (Controller).

- **Javadoc Comments:** Extensive Javadoc comments (Pre-Post conditions) are included to provide clear documentation for classes, methods, and their functionalities.

- **UML Diagram:** A UML diagram illustrates the relationships between classes, enhancing understanding of the overall structure.

## What I learned
Throughout the development of Lost cities – Minoan Civilization, I gained valuable insights and skills that have contributed to my growth as a developer:

- **Object-Oriented Concepts**: I deepened my understanding of Java classes, inheritance, encapsulation, and abstraction.

- **Abstract Data Types (ADT)**: Implementing game mechanics required the use of ADTs to manage findings and positions.

- **Interfaces**: I practiced the concept of interfaces by using them to define the behavior of the different types of cards.

- **Graphic Interface**: Developing a graphic interface and make it interact with the rest of the code.

- **Code Organization**: I learned to better structure my code by organizing it into separate files, resulting in a clearer and more maintainable codebase.

- **Javadoc Comments**: I recognized the significance of documenting code with Javadoc comments, ensuring better code comprehension for myself and others.

- **UML Design**: Creating a UML diagram provided a visual representation of class relationships, giving a deeper understanding of the project's architecture.


## Areas for improvement
While I am proud of the outcomes achieved, I acknowledge several aspects that could have been enhanced:

- **Dynamic UI Creation**: In retrospect, dynamically generating labels and UI components would have improved the interface creation process.

- **Code Refactoring**: Further refactoring could have led to cleaner, more efficient code and improved readability.

- **Code Reusability**: Identifying opportunities for code reuse in some parts and optimizing shared components could have resulted in a more modular design.


